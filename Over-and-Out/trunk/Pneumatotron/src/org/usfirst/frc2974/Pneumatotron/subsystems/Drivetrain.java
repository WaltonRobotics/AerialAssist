// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2974.Pneumatotron.subsystems;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc2974.Pneumatotron.RobotMap;
import org.usfirst.frc2974.Pneumatotron.commands.DriveWithJoysticks;

/**
 *
 */
public class Drivetrain extends Subsystem {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	final double ACCEL_CONSTANT = .2;//Arbitrary Units //in/s^2
	//**************************************************************************
	Encoder encoderRight = RobotMap.encoderRight;
	PIDController controllerRight = RobotMap.controllerRight;
	Encoder encoderLeft = RobotMap.encoderLeft;
	PIDController controllerLeft = RobotMap.controllerLeft;
	long prevTime = 0;
	long curTime = 0;
	int delay = 10;
	private double prevRight = 0;
	private double prevLeft = 0;
	private Talon right_1 = RobotMap.drivetrainRight_1;
	private Talon right_2 = RobotMap.drivetrainRight_2;
	private Talon left_1 = RobotMap.drivetrainLeft_1;
	private Talon left_2 = RobotMap.drivetrainLeft_2;
	private Solenoid shiftSolenoid = RobotMap.shifterSolenoid;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		setDefaultCommand(new DriveWithJoysticks());
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	}

	public void enableEncoders() {
		encoderRight.start();
		encoderLeft.start();
		encoderRight.reset();
		encoderLeft.reset();
	}

	public void stopEncoders() {
		encoderRight.stop();
		encoderLeft.stop();
		encoderRight.reset();
		encoderLeft.reset();
	}

	public void resetPrevious() {
		prevLeft = 0;
		prevRight = 0;
	}

	public void autoReset() {
		enableEncoders();
		resetPrevious();
	}

	public double getDistanceRight() {
		return encoderRight.getDistance();
	}

	public double getDistanceLeft() {
		return encoderLeft.getDistance();
	}

	public void driveManual(double right, double left) {
		right = fixAccel(prevRight, right);
		left = fixAccel(prevLeft, left);
		setRight(right);
		setLeft(left);
		prevLeft = left;
		prevRight = right;
	}

	public double fixAccel(double previousPower, double desiredPower) {
		if (Math.abs(previousPower - desiredPower) > ACCEL_CONSTANT) {
			if (previousPower > desiredPower) {
				desiredPower = previousPower - ACCEL_CONSTANT;//limit the speed on deceleration
			} else {
				desiredPower = previousPower + ACCEL_CONSTANT;//limit the speed on acceleration
			}
		} else { //desired remains the same
		}
		return desiredPower;
	}

	private void setRight(double speed) {
		speed *= -1;
		right_1.set(speed);
		right_2.set(speed);
	}

	private void setLeft(double speed) {
		left_1.set(speed);
		left_2.set(speed);
	}

	public void deadStop() {
		setRight(0);
		setLeft(0);
	}

	public void shiftToHigh(boolean shiftUp) {
		shiftSolenoid.set(shiftUp);
		//System.out.println(shiftUp ? "to High Gear" : "to Low Gear");
	}

	public boolean isHighGear() {
		return shiftSolenoid.get();
	}

	public void enableControl() {
		controllerRight.setSetpoint(0);
		controllerLeft.setSetpoint(0);
		enableEncoders();
		controllerRight.enable();
		controllerLeft.enable();
	}

	public void drive(double right, double left) {
		SmartDashboard.putNumber("Encoder Left", encoderLeft.pidGet());
		SmartDashboard.putNumber("Encoder Right", encoderRight.pidGet());

//        curTime = System.currentTimeMillis();
//        double dT = (curTime - prevTime) * 1000;
//        double accelRight = (right - prevRight) / dT;
//        double accelLeft = (left - prevLeft) / dT;
//        accelRight = Math.min(Math.max(accelRight, -ACCEL_CONSTANT), ACCEL_CONSTANT);
//        accelLeft = Math.min(Math.max(accelLeft, -ACCEL_CONSTANT), ACCEL_CONSTANT);
//        right = accelRight * dT + prevRight;
//        left = accelLeft * dT + prevLeft;

		controllerRight.setSetpoint(right);
		controllerLeft.setSetpoint(left);
		SmartDashboard.putNumber("Setpoint Right", controllerRight.getSetpoint());
		SmartDashboard.putNumber("Setpoint Left", controllerLeft.getSetpoint());
		prevRight = right;
		prevLeft = left;
		prevTime = curTime;
	}
}