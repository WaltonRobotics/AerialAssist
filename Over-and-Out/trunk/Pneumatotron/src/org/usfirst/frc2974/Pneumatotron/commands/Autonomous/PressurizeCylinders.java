// RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
package org.usfirst.frc2974.Pneumatotron.commands.Autonomous;

import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2974.Pneumatotron.Robot;
import org.usfirst.frc2974.Pneumatotron.subsystems.Shooter;

/**
 * Uses very, VERY complicated state system ;) It creates a series of nested
 * classes that implement the nested State interface. Each has an initial
 * behavior and a continuous execution, though some of these are empty. This is
 * employed for ease of use with a scheduler (StateContext) that mimics command
 * base.
 */
public class PressurizeCylinders extends Command {

    boolean isFinished = false;
    private static StateContext context;

    public PressurizeCylinders() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.shooter);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        //isFinished = false;
    }

    // Called just before this Command runs the first time
    protected void initialize() {
//        context = new StateContext();
//        isFinished = false;
        setTimeout(1);
        Robot.shooter.setLatch();
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        //context.execute();
        Robot.shooter.charge();
    }
    // Make this return true when this Command no longer needs to run execute()

    protected boolean isFinished() {
        return isTimedOut() || !Robot.oi.ds.isAutonomous();
    }
    // Called once after isFinished returns true

    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }

    //**************************************************************************
    /*
     * State Context Class *****************************************************
     */
    //**************************************************************************
    public class StateContext {

        private State state;

        /**
         * Standard constructor
         */
        public StateContext() {
            setState(new Relax());
        }

        /**
         * Setter method for the state. Normally only called by classes
         * implementing the State interface.
         *
         * @param newState the new state of this context
         */
        public final void setState(State newState) {
            state = newState;
            newState.initialize();
            tLast = System.currentTimeMillis();
        }

        /**
         * Writer method
         *
         * @param name the name to be written
         */
        public final void execute() {
            state.execute(this);
        }
        private long tLast;

        public final long getChangeMillis() {
            return System.currentTimeMillis() - tLast;
        }

        public void setLastTime() {
            tLast = System.currentTimeMillis();
        }
    }

    //**************************************************************************
    /*
     * STATE MACHINE BELOW *****************************************************
     */
    //**************************************************************************   
    public interface State {

        public void initialize();

        public void execute(StateContext context);
    }

    /*
     * This does what exactly? Releases a latch?
     */
    public class Relax implements State {

        private final long RELAX_DELAY = 500;
        private final long LATCH_DELAY = 200;

        public void initialize() {
            Robot.shooter.discharge();
        }

        public void execute(StateContext context) {
            long millis = context.getChangeMillis();
            if (millis > RELAX_DELAY) {
                context.setState(new Charge());
            } else if (millis > LATCH_DELAY && Robot.shooter.isLatched()) {
                //Robot.shooter.releaseLatch();
            }
        }
    }

    public class Charge implements State {

        private final long CHARGE_READY = 1000;
        private final long CHARGE_DELAY = 200;

        public void initialize() {
            Robot.shooter.setLatch();
        }

        public void execute(StateContext context) {
            long millis = context.getChangeMillis();
            if (millis > CHARGE_READY) {
                //context.setState(new Launch());
                isFinished = true;
            } else if (millis > CHARGE_DELAY && !Robot.shooter.isCharged()) {
                Robot.shooter.charge();
            }
        }
    }
}